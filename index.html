<html>
    <title>Three.js Drone</title>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r119/three.min.js"></script>
        <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"></script>
        <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r15/Stats.min.js"></script>
        <script src="lib/loaderUtils.js"></script>

        <script src="script/sceneObjectUtils.js"></script>
        <script src="script/lightingUtils.js"></script>
        <script src="script/shaderConfig.js"></script>
        <style>
			body { margin: 0; }
			canvas { display: block; }
            #statsContainer{
                position: fixed;
                top: 0px;
                left: 0px;
            }
		</style>
    </head>
    <body>
    </body>
    <script>
        let renderer, diffuseTarget, maskTarget;
        let scene, postScene;
        let camera, postCamera, controls;
        const lightGroup = {};
        let droneModel;
        let postMat, postPanelDim;

        const clock = new THREE.Clock();
        let stats;

        async function init(){
            stats = new Stats();
            stats.showPanel(0);
            stats.domElement.id = 'statsContainer';
            document.body.appendChild(stats.domElement);

            initSceneAndRenderer();
            initRenderTarget();
            await initPostScene();
            addLight();
            await addObject3D();
            setMaskSetup(true);
            animate();
        }

        // Init the renderer and scene
        function initSceneAndRenderer(){
            renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild(renderer.domElement);
            renderer.setClearColor(0x666666);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );

            camera.position.copy(new THREE.Vector3(0.0, 6.4, 5.0));
            // tool
            controls = new THREE.OrbitControls( camera, renderer.domElement);
            // controls.autoRotate = true;
        }

        // Init Post Scene
        async function initPostScene(){
            postScene = new THREE.Scene();
            // post panel
            const aspectRatio = window.innerWidth / window.innerHeight;
            const height = 4; 
            const width = height * aspectRatio;
            postPanelDim = new THREE.Vector2( width, height );
            postMat = new THREE.ShaderMaterial({
                uniforms: jet_post_uniforms,
                vertexShader: await loadShader('shader/jet_post.vert'),
                fragmentShader: await loadShader('shader/jet_post.frag')
            });
            const postPanel = new THREE.Mesh(
                new THREE.PlaneGeometry(
                    postPanelDim.x, postPanelDim.y, 1
                ),
                postMat
            )
            postScene.add(postPanel);
            
            // post camera
            postCamera = new THREE.OrthographicCamera(
                width / - 2, width / 2,
                height / 2, height / - 2,
                1,1000
            );
            postCamera.position.z = 100;
            postCamera.lookAt(0.0, 0.0, 0.0);
        }

        // Init the render target
        function initRenderTarget(){
            diffuseTarget = new THREE.WebGLRenderTarget(
                window.innerWidth,
                window.innerHeight,
                {
                    stencilBuffer: false,
                    encoding: THREE.LinearEncoding,
                    depthBuffer: true,
                    format: THREE.RGBFormat
                }
            );

            maskTarget = new THREE.WebGLRenderTarget(
                window.innerWidth,
                window.innerHeight,
                {
                    stencilBuffer: false,
                    encoding: THREE.LinearEncoding,
                    depthBuffer: true,
                    format: THREE.RGBFormat
                }
            );
        }

        // Kick off the render/ animation
        function animate(){
            stats.begin();

            const cTime = clock.getElapsedTime();
            jet_mask_uniforms.u_time.value = jet_post_uniforms.u_time = cTime;

            // 1. render image of the scene with lighting, without jet stream
            // render target
            setMaskSetup(false);
            renderer.setRenderTarget(diffuseTarget);
            renderer.render(scene, camera);

            // 2. turn off lighting and render jet stream (mask)
            // render target
            setMaskSetup(true);
            renderer.setRenderTarget(maskTarget);
            renderer.render(scene, camera);

            // 3. render final result of the scene with masked FX distortion
            renderer.setRenderTarget(null);

            jet_post_uniforms.u_diffuseTex.value = diffuseTarget.texture;
            jet_post_uniforms.u_maskTex.value = maskTarget.texture;
            
            renderer.render( postScene, postCamera );

            // controls.update();
            stats.end();
            requestAnimationFrame( animate );
        }

        function setMaskSetup( state ){
            toggleLighting(!state);
            toggleJetStream(state);
            renderer.setClearColor(state? 0x000000 : 0x666666);
        }

        // Kick off all
        init();

        // Utils
        window.addEventListener( 'resize', onWindowResize);
        function onWindowResize(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            postCamera.left = postPanelDim.x / - 2;
            postCamera.right = postPanelDim.x / 2;
            postCamera.top = postPanelDim.y / 2;
            postCamera.bottom = postPanelDim.y / - 2;
            postCamera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
        }
    </script>
</html>